// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

namespace Microsoft.LinuxTracepoints.Provider;

using System;
using System.Diagnostics;
using System.Diagnostics.Tracing;
using System.Text;

/// <summary>
/// Builder for events to be written through an <see cref="EventHeaderDynamicTracepoint"/>.
/// Create a <see cref="EventHeaderDynamicProvider"/> provider, use the provider to get a
/// <see cref="EventHeaderDynamicTracepoint"/> tracepoint. Create a
/// <see cref="EventHeaderDynamicBuilder"/> builder (or reuse an existing one to minimize
/// overhead), add data to it, and then call tracepoint.Write(builder) to emit the event.
/// </summary>
public class EventHeaderDynamicBuilder
{
    private Vector meta;
    private Vector data;

    /// <summary>
    /// Initializes a new instance of the EventBuilder.
    /// </summary>
    /// <param name="initialMetadataBufferSize">
    /// The initial capacity of the metadata buffer. This must be a power of 2 in the
    /// range 4 through 65536. Default is 256 bytes.
    /// </param>
    /// <param name="initialDataBufferSize">
    /// The initial capacity of the data buffer. This must be a power of 2 in the
    /// range 4 through 65536. Default is 256 bytes.
    /// </param>
    public EventHeaderDynamicBuilder(int initialMetadataBufferSize = 256, int initialDataBufferSize = 256)
        : this(Encoding.UTF8, initialMetadataBufferSize, initialDataBufferSize)
    {
        return;
    }

    /// <summary>
    /// Advanced scenarios: Initializes a new instance of the EventBuilder class that
    /// uses a customized UTF-8 encoding for event and field names.
    /// </summary>
    /// <param name="utf8NameEncoding">
    /// The customized UTF-8 encoding to use for event and field names.
    /// </param>
    /// <param name="initialMetadataBufferSize">
    /// The initial capacity of the metadata buffer. This must be a power of 2 in the
    /// range 4 through 65536.
    /// </param>
    /// <param name="initialDataBufferSize">
    /// The initial capacity of the data buffer. This must be a power of 2 in the
    /// range 4 through 65536.
    /// </param>
    public EventHeaderDynamicBuilder(
        Encoding utf8NameEncoding,
        int initialMetadataBufferSize = 256,
        int initialDataBufferSize = 256)
    {
        if (initialMetadataBufferSize < 4 || initialMetadataBufferSize > 65536 ||
            (initialMetadataBufferSize & (initialMetadataBufferSize - 1)) != 0)
        {
            throw new ArgumentOutOfRangeException(nameof(initialMetadataBufferSize));
        }

        if (initialDataBufferSize < 4 || initialDataBufferSize > 65536 ||
            (initialDataBufferSize & (initialDataBufferSize - 1)) != 0)
        {
            throw new ArgumentOutOfRangeException(nameof(initialDataBufferSize));
        }

        this.Utf8NameEncoding = utf8NameEncoding;
        this.meta = new Vector(initialMetadataBufferSize);
        this.data = new Vector(initialDataBufferSize);

        // The following has the same effect as Reset("").
        Debug.Assert(this.meta.Used == 0);
        Debug.Assert(this.meta.Bytes[0] == 0); // Since it was just allocated.
        this.meta.ReserveSpaceFor(1);
    }

    /// <summary>
    /// Advanced scenarios: Gets or sets the UTF-8 encoding that will be used for
    /// event and field names.
    /// </summary>
    public Encoding Utf8NameEncoding { get; set; }

    /// <summary>
    /// Provider-defined event tag, or 0 if none.
    /// Reset sets this to 0.
    /// </summary>
    public ushort Tag { get; private set; }

    /// <summary>
    /// Stable id for this event, or 0 if none.
    /// Reset sets this to 0.
    /// </summary>
    public ushort Id { get; private set; }

    /// <summary>
    /// Increment Version whenever event layout changes.
    /// Reset sets this to 0.
    /// </summary>
    public byte Version { get; private set; }

    /// <summary>
    /// EventOpcode raw value. (Stores the value of the Opcode property.)
    /// Reset sets this to 0 (Info).
    /// </summary>
    public byte OpcodeByte { get; private set; }

    /// <summary>
    /// EventOpcode: info, start activity, stop activity, etc.
    /// Reset sets this to 0 (Info).
    /// </summary>
    /// <remarks><para>
    /// Most events set Opcode = Info (0). Other Opcode values add special semantics to
    /// an event that help the event analysis tool with grouping related events. The
    /// most frequently-used special semantics are ActivityStart and ActivityStop.
    /// </para><para>
    /// To record an activity:
    /// </para><list type="bullet"><item>
    /// Generate a new activity id. An activity id is a 128-bit value that must be
    /// unique within the trace. This can be a UUID or it can be generated by any
    /// other id-generation system that is unlikely to create the same value for any
    /// other activity id in the same trace.
    /// </item><item>
    /// Write an event with opcode = ActivityStart and with an ActivityId header
    /// extension. The ActivityId extension should have the newly-generated activity
    /// id, followed by the id of a parent activity (if any). If there is a parent
    /// activity, the extension length will be 32; otherwise it will be 16.
    /// </item><item>
    /// As appropriate, write any number of normal events (events with opcode set to
    /// something other than ActivityStart or ActivityStop, e.g. opcode = Info). To
    /// indicate that the events are part of the activity, each of these events
    /// should have an ActivityId header extension with the new activity id
    /// (extension length will be 16).
    /// </item><item>
    /// When the activity ends, write an event with opcode = ActivityStop and with
    /// an ActivityId header extension containing the activity id of the activity
    /// that is ending (extension length will be 16).
    /// </item></list>
    /// </remarks>
    public EventOpcode Opcode => (EventOpcode) this.OpcodeByte;

    internal ReadOnlySpan<byte> Meta => this.meta.UsedSpan;

    internal ReadOnlySpan<byte> Data => this.data.UsedSpan;

    /// <summary>
    /// Clears the previous event (if any) from the builder and starts building a new event.
    /// Sets Tag, Id, Version, Opcode to 0.
    /// </summary>
    /// <param name="name">
    /// The event name for the new event. Must not contain any '\0' chars.
    /// </param>
    public EventHeaderDynamicBuilder Reset(ReadOnlySpan<char> name)
    {
        Debug.Assert(name.IndexOf('\0') < 0, "Event name must not have embedded NUL characters.");
        this.meta.Reset();
        this.data.Reset();
        this.Tag = 0;
        this.Id = 0;
        this.Version = 0;
        this.OpcodeByte = 0;

        this.meta.ReserveSpaceFor(this.Utf8NameEncoding.GetMaxByteCount(name.Length) + 1);
        var metaBytes = this.meta.Bytes.AsSpan();
        var nameUsed = this.Utf8NameEncoding.GetBytes(name, metaBytes);
        metaBytes[nameUsed++] = 0;
        this.meta.SetUsed(nameUsed);

        return this;
    }

    /// <summary>
    /// Clears the previous event (if any) from the builder and starts building a new event.
    /// Sets Tag, Id, Version, Opcode to 0.
    /// </summary>
    /// <param name="nameUtf8">
    /// UTF-8 encoded name for the new event. Must not contain any '\0' bytes.
    /// </param>
    /// <returns>this</returns>
    public EventHeaderDynamicBuilder Reset(ReadOnlySpan<byte> nameUtf8)
    {
        Debug.Assert(nameUtf8.IndexOf((byte)0) < 0, "Event name must not have embedded NUL characters.");
        this.meta.Reset();
        this.data.Reset();
        this.Tag = 0;
        this.Id = 0;
        this.Version = 0;
        this.OpcodeByte = 0;

        var nameLength = nameUtf8.Length;
        this.meta.ReserveSpaceFor(nameLength + 1);
        var metaBytes = this.meta.Bytes.AsSpan();
        nameUtf8.CopyTo(metaBytes);
        metaBytes[nameLength] = 0;
        this.meta.SetUsed(nameLength + 1);

        return this;
    }

    /// <summary>
    /// Sets the provider-defined event tag. Most events have tag 0 (default).
    /// </summary>
    /// <returns>this</returns>
    public EventHeaderDynamicBuilder SetTag(ushort tag)
    {
        this.Tag = tag;
        return this;
    }

    /// <summary>
    /// Sets the event's stable id and the event's version.
    /// Since events are frequently identified by name, many events use 0,
    /// indicating that they do not have any assigned stable id.
    /// </summary>
    /// <returns>this</returns>
    public EventHeaderDynamicBuilder SetIdVersion(ushort id, byte version)
    {
        this.Id = id;
        this.Version = version;
        return this;
    }

    /// <summary>
    /// EventOpcode: info, start activity, stop activity, etc.
    /// </summary>
    /// <returns>this</returns>
    /// <remarks><para>
    /// Most events set Opcode = Info (0). Other Opcode values add special semantics to
    /// an event that help the event analysis tool with grouping related events. The
    /// most frequently-used special semantics are ActivityStart and ActivityStop.
    /// </para><para>
    /// To record an activity:
    /// </para><list type="bullet"><item>
    /// Generate a new activity id. An activity id is a 128-bit value that must be
    /// unique within the trace. This can be a UUID or it can be generated by any
    /// other id-generation system that is unlikely to create the same value for any
    /// other activity id in the same trace.
    /// </item><item>
    /// Write an event with opcode = ActivityStart and with an ActivityId header
    /// extension. The ActivityId extension should have the newly-generated activity
    /// id, followed by the id of a parent activity (if any). If there is a parent
    /// activity, the extension length will be 32; otherwise it will be 16.
    /// </item><item>
    /// As appropriate, write any number of normal events (events with opcode set to
    /// something other than ActivityStart or ActivityStop, e.g. opcode = Info). To
    /// indicate that the events are part of the activity, each of these events
    /// should have an ActivityId header extension with the new activity id
    /// (extension length will be 16).
    /// </item><item>
    /// When the activity ends, write an event with opcode = ActivityStop and with
    /// an ActivityId header extension containing the activity id of the activity
    /// that is ending (extension length will be 16).
    /// </item></list>
    /// </remarks>
    public EventHeaderDynamicBuilder SetOpcodeByte(byte opcode)
    {
        this.OpcodeByte = opcode;
        return this;
    }

    /// <summary>
    /// EventOpcode: info, start activity, stop activity, etc.
    /// Throws OverflowException if value > 255.
    /// </summary>
    /// <returns>this</returns>
    /// <exception cref="OverflowException">value > 255</exception>
    /// <remarks><para>
    /// Most events set Opcode = Info (0). Other Opcode values add special semantics to
    /// an event that help the event analysis tool with grouping related events. The
    /// most frequently-used special semantics are ActivityStart and ActivityStop.
    /// </para><para>
    /// To record an activity:
    /// </para><list type="bullet"><item>
    /// Generate a new activity id. An activity id is a 128-bit value that must be
    /// unique within the trace. This can be a UUID or it can be generated by any
    /// other id-generation system that is unlikely to create the same value for any
    /// other activity id in the same trace.
    /// </item><item>
    /// Write an event with opcode = ActivityStart and with an ActivityId header
    /// extension. The ActivityId extension should have the newly-generated activity
    /// id, followed by the id of a parent activity (if any). If there is a parent
    /// activity, the extension length will be 32; otherwise it will be 16.
    /// </item><item>
    /// As appropriate, write any number of normal events (events with opcode set to
    /// something other than ActivityStart or ActivityStop, e.g. opcode = Info). To
    /// indicate that the events are part of the activity, each of these events
    /// should have an ActivityId header extension with the new activity id
    /// (extension length will be 16).
    /// </item><item>
    /// When the activity ends, write an event with opcode = ActivityStop and with
    /// an ActivityId header extension containing the activity id of the activity
    /// that is ending (extension length will be 16).
    /// </item></list>
    /// </remarks>
    public EventHeaderDynamicBuilder SetOpcode(EventOpcode opcode)
    {
        this.OpcodeByte = checked((byte)opcode);
        return this;
    }

    private struct Vector
    {
        public Vector(int initialCapacity)
        {
            Debug.Assert(0 < initialCapacity, "initialCapacity <= 0");
            Debug.Assert(initialCapacity <= 65536, "initialCapacity > 65536");
            Debug.Assert((initialCapacity & (initialCapacity - 1)) == 0, "initialCapacity is not a power of 2.");
            this.Bytes = new byte[initialCapacity];
            this.Used = 0;
        }

        public byte[] Bytes { get; private set; }

        public int Used { get; private set; }

        public ReadOnlySpan<byte> UsedSpan => new ReadOnlySpan<byte>(this.Bytes, 0, this.Used);

        public void Reset()
        {
            this.Used = 0;
        }

        public int ReserveSpaceFor(int requiredSize)
        {
            int oldUsed = this.Used;
            if (this.Bytes.Length - oldUsed < requiredSize)
            {
                this.Grow(requiredSize);
            }

            this.Used += requiredSize;
            return oldUsed;
        }

        public void SetUsed(int newUsed)
        {
            Debug.Assert(newUsed <= this.Used);
            this.Used = newUsed;
        }

        private void Grow(int requiredSize)
        {
            int newCapacity = this.Bytes.Length;
            while (true)
            {
                newCapacity *= 2;

                if (newCapacity > 65536)
                {
                    throw new InvalidOperationException("Event too large");
                }

                if (newCapacity - this.Used >= requiredSize)
                {
                    break;
                }
            }

            var newArray = new byte[newCapacity];
            Buffer.BlockCopy(this.Bytes, 0, newArray, 0, this.Used);
            this.Bytes = newArray;
        }
    }
}
